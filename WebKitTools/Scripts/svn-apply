#!/usr/bin/perl -w

# Copyright (C) 2005, 2006, 2007 Apple Inc.  All rights reserved.
# Copyright (C) 2009 Cameron McCormack <cam@mcc.id.au>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# "patch" script for WebKit Open Source Project, used to apply patches.

# Differences from invoking "patch -p0":
#
#   Handles added files (does a svn add with logic to handle local changes).
#   Handles added directories (does a svn add).
#   Handles removed files (does a svn rm with logic to handle local changes).
#   Handles removed directories--those with no more files or directories left in them
#       (does a svn rm).
#   Has mode where it will roll back to svn version numbers in the patch file so svn
#       can do a 3-way merge.
#   Paths from Index: lines are used rather than the paths on the patch lines, which
#       makes patches generated by "cvs diff" work (increasingly unimportant since we
#       use Subversion now).
#   ChangeLog patches use --fuzz=3 to prevent rejects, and the entry date is set in
#       the patch to today's date using $changeLogTimeZone.
#   Handles binary files (requires patches made by svn-create-patch).
#   Handles copied and moved files (requires patches made by svn-create-patch).
#   Handles git-diff patches (without binary changes) created at the top-level directory
#
# Missing features:
#
#   Handle property changes.
#   Handle copied and moved directories (would require patches made by svn-create-patch).
#   When doing a removal, check that old file matches what's being removed.
#   Notice a patch that's being applied at the "wrong level" and make it work anyway.
#   Do a dry run on the whole patch and don't do anything if part of the patch is
#       going to fail (probably too strict unless we exclude ChangeLog).
#   Handle git-diff patches with binary delta

use strict;
use warnings;

use Digest::MD5;
use File::Basename;
use File::Spec;
use Getopt::Long;
use MIME::Base64;
use POSIX qw(strftime);

use FindBin;
use lib $FindBin::Bin;
use VCSUtils;

sub addDirectoriesIfNeeded($);
sub applyPatch($$;$);
sub checksum($);
sub handleBinaryChange($$);
sub handleGitBinaryChange($$);
sub isDirectoryEmptyForRemoval($);
sub patch($);
sub removeDirectoriesIfNeeded();
sub setChangeLogDateAndReviewer($$);

# These should be replaced by an scm class/module:
sub scmKnowsOfFile($);
sub scmCopy($$);
sub scmAdd($);
sub scmRemove($);


# Project time zone for Cupertino, CA, US
my $changeLogTimeZone = "PST8PDT";

my $merge = 0;
my $showHelp = 0;
my $reviewer;
my $force = 0;

my $optionParseSuccess = GetOptions(
    "merge!" => \$merge,
    "help!" => \$showHelp,
    "reviewer=s" => \$reviewer,
    "force!" => \$force
);

if (!$optionParseSuccess || $showHelp) {
    print STDERR basename($0) . " [-h|--help] [--force] [-m|--merge] [-r|--reviewer name] patch1 [patch2 ...]\n";
    exit 1;
}

my %removeDirectoryIgnoreList = (
    '.' => 1,
    '..' => 1,
    '.git' => 1,
    '.svn' => 1,
    '_svn' => 1,
);

my $globalExitCode = 0;

my $pathScriptWasRunFrom = Cwd::getcwd();
my $pathForRepositoryRoot = determineVCSRoot();

my %checkedDirectories;
my %copiedFiles;
my @patches;
my %versions;

my $copiedFromPath;
my $filter;
my $indexPath;
my $patch;
while (<>) {
    s/([\n\r]+)$//mg;
    my $eol = $1;
    if (!defined($indexPath) && m#^diff --git a/#) {
        $filter = \&gitdiff2svndiff;
    }
    $_ = &$filter($_) if $filter;
    if (/^Index: (.+)/) {
        $indexPath = $1;
        if ($patch) {
            if (!$copiedFromPath) {
                push @patches, $patch;
            }
            $copiedFromPath = "";
            $patch = "";
        }
    }
    if ($indexPath) {
        # Fix paths on diff, ---, and +++ lines to match preceding Index: line.
        s/\S+$/$indexPath/ if /^diff/;
        s/^--- \S+/--- $indexPath/;
        if (/^--- .+\(from (\S+):(\d+)\)$/) {
            $copiedFromPath = $1;
            $copiedFiles{$indexPath} = $copiedFromPath;
            $versions{$copiedFromPath} = $2 if ($2 != 0);
        }
        elsif (/^--- .+\(revision (\d+)\)$/) {
            $versions{$indexPath} = $1 if ($1 != 0);
        }
        if (s/^\+\+\+ \S+/+++ $indexPath/) {
            $indexPath = "";
        }
    }
    $patch .= $_;
    $patch .= $eol;
}

if ($patch && !$copiedFromPath) {
    push @patches, $patch;
}

if ($merge) {
    die "--merge is currently only supported for SVN" unless isSVN();
    # How do we handle Git patches applied to an SVN checkout here?
    for my $file (sort keys %versions) {
        my $version = $versions{$file};
        print "Getting version $version of $file\n";
        system("svn", "update", "-r", $version, $file) == 0 or die "Failed to run svn update -r $version $file.";
    }
}

# Handle copied and moved files first since moved files may have their source deleted before the move.
for my $file (keys %copiedFiles) {
    addDirectoriesIfNeeded(dirname($file));
    scmCopy($copiedFiles{$file}, $file);
}

for $patch (@patches) {
    patch($patch);
}

removeDirectoriesIfNeeded();

exit $globalExitCode;

sub addDirectoriesIfNeeded($)
{
    my ($path) = @_;
    my @dirs = File::Spec->splitdir($path);
    my $dir = ".";
    while (scalar @dirs) {
        $dir = File::Spec->catdir($dir, shift @dirs);
        next if exists $checkedDirectories{$dir};
        if (! -e $dir) {
            mkdir $dir or die "Failed to create required directory '$dir' for path '$path'\n";
            scmAdd($dir);
            $checkedDirectories{$dir} = 1;
        }
        elsif (-d $dir) {
            # SVN prints "svn: warning: 'directory' is already under version control"
            # if you try and add a directory which is already in the repository.
            # Git will ignore the add, but re-adding large directories can be sloooow.
            # So we check first to see if the directory is under version control first.
            if (!scmKnowsOfFile($dir)) {
                scmAdd($dir);
            }
            $checkedDirectories{$dir} = 1;
        }
        else {
            die "'$dir' exists, but is not a directory";
        }
    }
}

sub applyPatch($$;$)
{
    my ($patch, $fullPath, $options) = @_;
    chdir $pathForRepositoryRoot;
    $options = [] if (! $options);
    push @{$options}, "--force" if $force;
    my $command = "patch " . join(" ", "-p0", @{$options});
    open PATCH, "| $command" or die "Failed to patch $fullPath\n";
    print PATCH $patch;
    close PATCH;
    chdir $pathScriptWasRunFrom;

    my $exitCode = $? >> 8;
    if ($exitCode) {
        if (!$force) {
            print "$command \"$fullPath\" returned $exitCode.  Pass --force to ignore patch failures.\n";
            exit $exitCode;
        }
        $globalExitCode = $exitCode;
    }
}

sub checksum($)
{
    my $file = shift;
    open(FILE, $file) or die "Can't open '$file': $!";
    binmode(FILE);
    my $checksum = Digest::MD5->new->addfile(*FILE)->hexdigest();
    close(FILE);
    return $checksum;
}

sub handleBinaryChange($$)
{
    my ($fullPath, $contents) = @_;
    # [A-Za-z0-9+/] is the class of allowed base64 characters.
    # One or more lines, at most 76 characters in length.
    # The last line is allowed to have up to two '=' characters at the end (to signify padding).
    if ($contents =~ m#((\n[A-Za-z0-9+/]{76})*\n[A-Za-z0-9+/]{2,74}?[A-Za-z0-9+/=]{2}\n)#) {
        # Addition or Modification
        open FILE, ">", $fullPath or die "Failed to open $fullPath.";
        print FILE decode_base64($1);
        close FILE;
        if (!scmKnowsOfFile($fullPath)) {
            # Addition
            scmAdd($fullPath);
        }
    } else {
        # Deletion
        scmRemove($fullPath);
    }
}

sub handleGitBinaryChange($$)
{
    my ($fullPath, $contents) = @_;

    my ($binaryChunkType, $binaryChunk, $reverseBinaryChunkType, $reverseBinaryChunk) = decodeGitBinaryPatch($contents, $fullPath);
    # FIXME: support "delta" type.
    die "only literal type is supported now" if ($binaryChunkType ne "literal" || $reverseBinaryChunkType ne "literal");

    my $isFileAddition = $contents =~ /\nnew file mode \d+\n/;
    my $isFileDeletion = $contents =~ /\ndeleted file mode \d+\n/;

    my $originalContents = "";
    if (open FILE, $fullPath) {
        die "$fullPath already exists" if $isFileAddition;

        $originalContents = join("", <FILE>);
        close FILE;
    }
    die "Original content of $fullPath mismatches" if $originalContents ne $reverseBinaryChunk;

    if ($isFileDeletion) {
        scmRemove($fullPath);
    } else {
        # Addition or Modification
        open FILE, ">", $fullPath or die "Failed to open $fullPath.";
        print FILE $binaryChunk;
        close FILE;
        if ($isFileAddition) {
            scmAdd($fullPath);
        }
    }
}

sub isDirectoryEmptyForRemoval($)
{
    my ($dir) = @_;
    my $directoryIsEmpty = 1;
    opendir DIR, $dir or die "Could not open '$dir' to list files: $?";
    for (my $item = readdir DIR; $item && $directoryIsEmpty; $item = readdir DIR) {
        next if exists $removeDirectoryIgnoreList{$item};
        if (! -d File::Spec->catdir($dir, $item)) {
            $directoryIsEmpty = 0;
        } else {
            next if (scmWillDeleteFile(File::Spec->catdir($dir, $item)));
            $directoryIsEmpty = 0;
        }
    }
    closedir DIR;
    return $directoryIsEmpty;
}

sub patch($)
{
    my ($patch) = @_;
    return if !$patch;

    unless ($patch =~ m|^Index: ([^\r\n]+)|) {
        my $separator = '-' x 67;
        warn "Failed to find 'Index:' in:\n$separator\n$patch\n$separator\n";
        die unless $force;
        return;
    }
    my $fullPath = $1;

    my $deletion = 0;
    my $addition = 0;
    my $isBinary = 0;
    my $isGitBinary = 0;

    $addition = 1 if ($patch =~ /\n--- .+\(revision 0\)\r?\n/ || $patch =~ /\n@@ -0,0 .* @@/) && !exists($copiedFiles{$fullPath});
    $deletion = 1 if $patch =~ /\n@@ .* \+0,0 @@/;
    $isBinary = 1 if $patch =~ /\nCannot display: file marked as a binary type\./;
    $isGitBinary = 1 if $patch =~ /\nGIT binary patch\n/;

    if (!$addition && !$deletion && !$isBinary && !$isGitBinary) {
        # Standard patch, patch tool can handle this.
        if (basename($fullPath) eq "ChangeLog") {
            my $changeLogDotOrigExisted = -f "${fullPath}.orig";
            applyPatch(setChangeLogDateAndReviewer(fixChangeLogPatch($patch), $reviewer), $fullPath, ["--fuzz=3"]);
            unlink("${fullPath}.orig") if (! $changeLogDotOrigExisted);
        } else {
            applyPatch($patch, $fullPath);
        }
    } else {
        # Either a deletion, an addition or a binary change.

        addDirectoriesIfNeeded(dirname($fullPath));

        if ($isBinary) {
            # Binary change
            handleBinaryChange($fullPath, $patch);
        } elsif ($isGitBinary) {
            # Git binary change
            handleGitBinaryChange($fullPath, $patch);
        } elsif ($deletion) {
            # Deletion
            applyPatch($patch, $fullPath, ["--force"]);
            scmRemove($fullPath);
        } else {
            # Addition
            rename($fullPath, "$fullPath.orig") if -e $fullPath;
            applyPatch($patch, $fullPath);
            unlink("$fullPath.orig") if -e "$fullPath.orig" && checksum($fullPath) eq checksum("$fullPath.orig");
            scmAdd($fullPath);
            # What is this for?
            system("svn", "stat", "$fullPath.orig") if isSVN() && -e "$fullPath.orig";
        }
    }
}

sub removeDirectoriesIfNeeded()
{
    foreach my $dir (reverse sort keys %checkedDirectories) {
        if (isDirectoryEmptyForRemoval($dir)) {
            scmRemove($dir);
        }
    }
}

sub setChangeLogDateAndReviewer($$)
{
    my $patch = shift;
    my $reviewer = shift;
    my $savedTimeZone = $ENV{'TZ'};
    # Set TZ temporarily so that localtime() is in that time zone
    $ENV{'TZ'} = $changeLogTimeZone;
    my $newDate = strftime("%Y-%m-%d", localtime());
    if (defined $savedTimeZone) {
         $ENV{'TZ'} = $savedTimeZone;
    } else {
         delete $ENV{'TZ'};
    }
    $patch =~ s/(\n\+)\d{4}-[^-]{2}-[^-]{2}(  )/$1$newDate$2/;
    if (defined($reviewer)) {
        $patch =~ s/NOBODY \(OOPS!\)/$reviewer/;
    }
    return $patch;
}

# This could be made into a more general "status" call, except svn and git
# have different ideas about "moving" files which might get confusing.
sub scmWillDeleteFile($)
{
    my ($path) = @_;
    if (isSVN()) {
        my $svnOutput = svnStatus($path);
        return 1 if $svnOutput && substr($svnOutput, 0, 1) eq "D";
    } elsif (isGit()) {
        my $gitOutput = `git diff-index --name-status HEAD -- $path`;
        return 1 if $gitOutput && substr($gitOutput, 0, 1) eq "D";
    }
    return 0;
}

sub scmKnowsOfFile($)
{
    my ($path) = @_;
    if (isSVN()) {
        my $svnOutput = svnStatus($path);
        # This will match more than intended.  ? might not be the first field in the status
        if ($svnOutput && $svnOutput =~ m#\?\s+$path\n#) {
            return 0;
        }
        # This does not handle errors well.
        return 1;
    } elsif (isGit()) {
        `git ls-files --error-unmatch -- $path`;
        my $exitCode = $? >> 8;
        return $exitCode == 0;
    }
}

sub scmCopy($$)
{
    my ($source, $destination) = @_;
    if (isSVN()) {
        system("svn", "copy", $source, $destination) == 0 or die "Failed to svn copy $source $destination.";
    } elsif (isGit()) {
        system("cp", $source, $destination) == 0 or die "Failed to copy $source $destination.";
        system("git", "add", $destination) == 0 or die "Failed to git add $destination.";
    }
}

sub scmAdd($)
{
    my ($path) = @_;
    if (isSVN()) {
        system("svn", "add", $path) == 0 or die "Failed to svn add $path.";
    } elsif (isGit()) {
        system("git", "add", $path) == 0 or die "Failed to git add $path.";
    }
}

sub scmRemove($)
{
    my ($path) = @_;
    if (isSVN()) {
        # SVN is very verbose when removing directories.  Squelch all output except the last line.
        my $svnOutput;
        open SVN, "svn rm --force '$path' |" or die "svn rm --force '$path' failed!";
        # Only print the last line.  Subversion outputs all changed statuses below $dir
        while (<SVN>) {
            $svnOutput = $_;
        }
        close SVN;
        print $svnOutput if $svnOutput;
    } elsif (isGit()) {
        system("git", "rm", "--force", $path) == 0 or die  "Failed to git rm --force $path.";
    }
}
