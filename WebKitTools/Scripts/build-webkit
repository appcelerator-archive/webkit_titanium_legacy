#!/usr/bin/perl -w

# Copyright (C) 2005, 2006 Apple Computer, Inc.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
#
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Build script wrapper for the WebKit Open Source Project.

use strict;
use File::Basename;
use File::Spec;
use FindBin;
use Getopt::Long qw(:config pass_through);
use lib $FindBin::Bin;
use webkitdirs;
use POSIX;

my $originalWorkingDirectory = getcwd();
chdirWebKit();

my $showHelp = 0;
my $clean = 0;
my $makeArgs;

my ($threeDRenderingSupport, $channelMessagingSupport, $databaseSupport, $domStorageSupport,
    $filtersSupport, $geolocationSupport, $gnomeKeyringSupport, $iconDatabaseSupport,
    $javaScriptDebuggerSupport, $offlineWebApplicationSupport, $rubySupport, $sharedWorkersSupport, 
    $svgSupport, $svgAnimationSupport, $svgAsImageSupport, $svgDOMObjCBindingsSupport, $svgFontsSupport,
    $svgForeignObjectSupport, $svgUseSupport, $videoSupport, $webSocketsSupport, $wmlSupport, $workersSupport,
    $xpathSupport, $xsltSupport, $coverageSupport);

my @features = (
    { option => "3d-rendering", desc => "Toggle 3D rendering support",
      define => "ENABLE_3D_RENDERING", default => (isAppleMacWebKit() && !isTiger()), value => \$threeDRenderingSupport },

    { option => "channel-messaging", desc => "Toggle MessageChannel and MessagePort support",
      define => "ENABLE_CHANNEL_MESSAGING", default => 1, value => \$channelMessagingSupport },

    { option => "coverage", desc => "Toggle code coverage support",
      define => "", default => 0, value => \$coverageSupport },

    { option => "database", desc => "Toggle Database Support",
      define => "ENABLE_DATABASE", default => 1, value => \$databaseSupport },

    { option => "dom-storage", desc => "Toggle DOM Storage Support",
      define => "ENABLE_DOM_STORAGE", default => 1, value => \$domStorageSupport },

    { option => "filters", desc => "Toggle Filters support",
      define => "ENABLE_FILTERS", default => 0, value => \$filtersSupport },

    { option => "geolocation", desc => "Toggle Geolocation support",
      define => "ENABLE_GEOLOCATION", default => 0, value => \$geolocationSupport },

    { option => "gnomekeyring", desc => "Toggle GNOME Keyring Support (GTK+ port only)",
      define => "WTF_USE_GNOMEKEYRING", default => 0, value => \$gnomeKeyringSupport },

    { option => "icon-database", desc => "Toggle Icon database support",
      define => "ENABLE_ICONDATABASE", default => 1, value => \$iconDatabaseSupport },

    { option => "javascript-debugger", desc => "Toggle JavaScript Debugger/Profiler support",
      define => "ENABLE_JAVASCRIPT_DEBUGGER", default => 1, value => \$javaScriptDebuggerSupport },

    { option => "offline-web-applications", desc => "Toggle Offline Web Application Support",
      define => "ENABLE_OFFLINE_WEB_APPLICATIONS", default => 1, value => \$offlineWebApplicationSupport },

    { option => "ruby", desc => "Toggle HTML5 Ruby support",
      define => "ENABLE_RUBY", default => 1, value => \$rubySupport },

    { option => "shared-workers", desc => "Toggle SharedWorkers support",
      define => "ENABLE_SHARED_WORKERS", default => 0, value => \$sharedWorkersSupport },

    { option => "svg", desc => "Toggle SVG support",
      define => "ENABLE_SVG", default => 1, value => \$svgSupport },

    { option => "svg-animation", desc => "Toggle SVG animation support (implies SVG support)",
      define => "ENABLE_SVG_ANIMATION", default => 1, value => \$svgAnimationSupport },

    { option => "svg-as-image", desc => "Toggle SVG as Image support (implies SVG support)",
      define => "ENABLE_SVG_AS_IMAGE", default => 1, value => \$svgAsImageSupport },

    { option => "svg-dom-objc-bindings", desc => "Toggle SVG DOM Objective-C bindings support (implies SVG support)",
      define => "ENABLE_SVG_DOM_OBJC_BINDINGS", default => isAppleMacWebKit(), value => \$svgDOMObjCBindingsSupport },

    { option => "svg-fonts", desc => "Toggle SVG fonts support (imples SVG support)",
      define => "ENABLE_SVG_FONTS", default => 1, value => \$svgFontsSupport },

    { option => "svg-foreign-object", desc => "Toggle SVG foreign object support (implies SVG support)",
      define => "ENABLE_SVG_FOREIGN_OBJECT", default => 1, value => \$svgForeignObjectSupport },

    { option => "svg-use", desc => "Toggle SVG use element support (implies SVG support)",
      define => "ENABLE_SVG_USE", default => 1, value => \$svgUseSupport },

    { option => "video", desc => "Toggle Video support",
      define => "ENABLE_VIDEO", default => (isAppleWebKit() || isGtk()), value => \$videoSupport },

    { option => "web-sockets", desc => "Toggle Web Sockets support",
      define => "ENABLE_WEB_SOCKETS", default => 1, value=> \$webSocketsSupport },

    { option => "wml", desc => "Toggle WML support",
      define => "ENABLE_WML", default => 0, value => \$wmlSupport },

    { option => "workers", desc => "Toggle Web Workers support",
      define => "ENABLE_WORKERS", default => (isAppleWebKit() || isGtk()), value => \$workersSupport },

    { option => "xpath", desc => "Toggle XPath support",
      define => "ENABLE_XPATH", default => 1, value => \$xpathSupport },

    { option => "xslt", desc => "Toggle XSLT support",
      define => "ENABLE_XSLT", default => 1, value => \$xsltSupport },
);

# Update defaults from Qt's project file
if (isQt()) {
    my %qtDefaults = qtFeatureDefaults();
    foreach (@features) {
        $_->{default} = $qtDefaults{$_->{define}} || 0;
    }
}

# Initialize values from defaults
foreach (@features) {
    ${$_->{value}} = $_->{default} || 0;
}

$svgSupport = $svgSupport || $svgAnimationSupport || $svgAsImageSupport
    || $svgDOMObjCBindingsSupport || $svgFontsSupport
    || $svgForeignObjectSupport || $svgUseSupport;


my $programName = basename($0);
my $usage = <<EOF;
Usage: $programName [options] [options to pass to build system]
  --help                            Show this help message
  --clean                           Cleanup the build directory
  --debug                           Compile in debug mode
  --cairo-win32                     Build using Cairo (rather than CoreGraphics) on Windows
  --chromium                        Build the Chromium port on Mac/Win/Linux
  --gtk                             Build the GTK+ port
  --qt                              Build the Qt port

  --makeargs=<arguments>            Optional Makefile flags

EOF

my %options = (
    'help' => \$showHelp,
    'clean' => \$clean,
    'makeargs=s' => \$makeArgs,
);

# Build usage text and options list from features
foreach (@features) {
    my $opt = sprintf("%-35s", "  --[no-]$_->{option}");
    $usage .= "$opt $_->{desc} (default: ${$_->{value}})\n";
    $options{"$_->{option}!"} =  $_->{value};
}

GetOptions(%options);

if ($showHelp) {
   print STDERR $usage;
   exit 1;
}

checkRequiredSystemConfig();
setConfiguration();

if (isWx()) {
    $ENV{"WEBKITOUTPUTDIR"} = productDir();

    my @opts = getWxArgs();

    if ($clean) {
        push(@opts, "clean");
    }
    system "WebKitTools/wx/build-wxwebkit @opts";
    exit exitStatus($?);
}

my $productDir = productDir();

# Check that all the project directories are there.
my @projects = ("JavaScriptCore", "WebCore", "WebKit");
# Only Apple builds JavaScriptGlue, and only on the Mac
splice @projects, 1, 0, "JavaScriptGlue" if isAppleMacWebKit();

my @otherDirs = ("WebKitLibraries");
for my $dir (@projects, @otherDirs) {
    if (! -d $dir) {
        die "Error: No $dir directory found. Please do a fresh checkout.\n";
    }
}

my @options = ();

# enable autotool options accordingly
if (isGtk()) {
    foreach (@features) {
        push @options, autotoolsFlag(${$_->{value}}, $_->{option});
    }

    push @options, "--makeargs=" . $makeArgs if defined($makeArgs);
} elsif (isAppleMacWebKit()) {
    push @options, XcodeOptions();

    sub option($$)
    {
        my ($feature, $isEnabled) = @_;
        return $feature . "=" . ($isEnabled ? $feature : " ");
    }

    foreach (@features) {
        if ($_->{option} eq "coverage") {
            push @options, XcodeCoverageSupportOptions() if $coverageSupport;
        } else {
            push @options, option($_->{define}, ${$_->{value}});
        }
    }

    # Copy library and header from WebKitLibraries to a findable place in the product directory.
    my $srcLib = "WebKitLibraries/libWebKitSystemInterfaceTiger.a";
    my $lib = "$productDir/libWebKitSystemInterfaceTiger.a";
    if (!-e $lib || -M $lib > -M $srcLib) {
        print "Updating $lib\n";
        system "ditto", $srcLib, $lib;
        system "ranlib", $lib;
    }

    $srcLib = "WebKitLibraries/libWebKitSystemInterfaceLeopard.a";
    $lib = "$productDir/libWebKitSystemInterfaceLeopard.a";
    if (!-e $lib || -M $lib > -M $srcLib) {
        print "Updating $lib\n";
        system "ditto", $srcLib, $lib;
        system "ranlib", $lib;
    }

    $srcLib = "WebKitLibraries/libWebKitSystemInterfaceSnowLeopard.a";
    $lib = "$productDir/libWebKitSystemInterfaceSnowLeopard.a";
    if (!-e $lib || -M $lib > -M $srcLib) {
        print "Updating $lib\n";
        system "ditto", $srcLib, $lib;
        system "ranlib", $lib;
    }

    my $srcHeader = "WebKitLibraries/WebKitSystemInterface.h";
    my $header = "$productDir/usr/local/include/WebKitSystemInterface.h";
    if (!-e $header || -M $header > -M $srcHeader) {
        print "Updating $header\n";
        system "mkdir", "-p", "$productDir/usr/local/include";
        system "ditto", $srcHeader, $header;
    }

    $srcLib = "WebKitLibraries/libWebCoreSQLite3.a";
    $lib = "$productDir/libWebCoreSQLite3.a";
    if (!-e $lib || -M $lib > -M $srcLib) {
        print "Updating $lib\n";
        system "ditto", $srcLib, $lib;
        system "ranlib", $lib;
    }

    my $srcHeaderDir = "WebKitLibraries/WebCoreSQLite3";
    my $headerDir = "$productDir/WebCoreSQLite3";
    if (!-e $headerDir || -M $headerDir > -M $srcHeaderDir) {
        print "Updating $headerDir\n";
        system "ditto", $srcHeaderDir, $headerDir;
    }
} elsif (isAppleWinWebKit()) {
    # Copy WebKitSupportLibrary to the correct location in WebKitLibraries so it can be found.
    # Will fail if WebKitSupportLibrary.zip is not in source root.
    (system("perl WebKitTools/Scripts/update-webkit-support-libs") == 0) or die;
} elsif (isQt()) {
    @options = @ARGV;
    push @options, "--makeargs=" . $makeArgs if defined($makeArgs);

    foreach (@features) {
        push @options, "DEFINES+=$_->{define}=${$_->{value}}" if ${$_->{value}} != $_->{default};
    }
}

# Force re-link of existing libraries if different than expected
removeLibraryDependingOnSVG("WebCore", $svgSupport);

# Build, and abort if the build fails.
for my $dir (@projects) {
    chdir $dir or die;
    my $result = 0;

    # For Gtk and Qt the WebKit project builds all others
    if ((isGtk() || isQt()) && $dir ne "WebKit") {
        chdir ".." or die;
        next;
    }

    if (isGtk()) {
        $result = buildGtkProject($dir, $clean,  @options);
    } elsif (isQt()) {
        $result = buildQMakeQtProject($dir, $clean, @options);
    } elsif (isAppleMacWebKit()) {
        $result = buildXCodeProject($dir, $clean, @options, @ARGV);
    } elsif (isAppleWinWebKit()) {
        if ($dir eq "WebKit") {
            $result = buildVisualStudioProject("win/WebKit.vcproj/WebKit.sln", $clean);
        }
    }

    if (exitStatus($result)) {
        if (isAppleWinWebKit()) {
            print "\n\n===== BUILD FAILED ======\n\n";
            my $scriptDir = relativeScriptsDir();
            print "Please ensure you have run $scriptDir/update-webkit to install depenedencies.\n\n";
            my $baseProductDir = baseProductDir();
            print "You can view build errors by checking the BuildLog.htm files located at:\n$baseProductDir/obj/<project>/<config>.\n";
        }
        exit exitStatus($result);
    }
    chdir ".." or die;
}

# Don't report the "WebKit is now built" message after a clean operation.
exit if $clean;

# Write out congratulations message.

my $launcherPath = launcherPath();
my $launcherName = launcherName();

print "\n";
print "===========================================================\n";
print " WebKit is now built. To run $launcherName with this newly-built\n";
print " code, use the \"$launcherPath\" script.\n";
if ($svgSupport) {
    print "\n NOTE: WebKit has been built with SVG support enabled.\n";
    print " $launcherName will have SVG viewing capabilities.\n";
}
if ($svgAnimationSupport or $svgAsImageSupport or $svgDOMObjCBindingsSupport or $svgFontsSupport or $svgForeignObjectSupport or $svgUseSupport) {
    print " Your build supports the following (optional) SVG features: \n";
    print "  * Basic SVG animation.\n" if $svgAnimationSupport;
    print "  * SVG as image.\n" if $svgAsImageSupport;
    print "  * SVG DOM Objective-C bindings.\n" if $svgDOMObjCBindingsSupport;
    print "  * SVG fonts.\n" if $svgFontsSupport;
    print "  * SVG foreign object.\n" if $svgForeignObjectSupport;
    print "  * SVG <use> support.\n" if $svgUseSupport;
}
print "===========================================================\n";

exit 0;
